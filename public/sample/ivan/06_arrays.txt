# title: Массивы

# Они есть. Но у них есть одно жесткое ограничение
# Суммарный размер всех массивов не должен превышать 256
# У меня есть пара идей, как это ограничение снять, но пока так.

# Все массивы в программе bf хранятся как один длинный массив
# Расположены после блока с переменными
# Каждый элемент массива занимает 2 ячейки. Одна для счетчика, другая для значения.
# В профилировщике они все обозначены

# Также для обхода массивов резервируются две служебные ячейки: adr_s и adr_d.
# Они находятся перед значениями массивов

# Вот программка, которая делает reverse текста

char str[256];

in str; # in умеет вводить символьные массивы. Читает до новой строки
        # На размер массива он не смотрит...
        # Поэтому может случайно перезаписать значения других массивов)

for (byte i = 255; i > 0; i--) {
    out str[i];
}
out str[0]; # Костыль. Мы не можем в цикле указать i >= 0,
            # потому что 0-- сделает i = 256 и мы получим бесконечный цикл


str = '\n\nОператор "=" также умеет быстро заполнять массивы...\n
И кратно увеличивать кол-во кода bf)';

out str; # out умеет выводить символьные массивы


# Еще можно заполнить все ячейки массива скалярным значением: str = 123; или str = 'A';
# Строковые и символьные литералы у меня различаются по длине строки, а не по кавычкам.
# Поэтому 'А' или '\n' это символ, а 'А\n' - строка
# И поэтому str = 'A' заполняет весь массив одним символом, а не строкой
# Мб переделаю, чтобы было как в си
# Еще массив, конечно, можно заполнить так: str = [1, 2, 3]; Недостающие значения заполнятся нулями



ямап туртос ,тяничоп оге икинхет ,адеб ен — илибу атобор илсЕ .йивтсйед удобовс юунлоп и ьтсонназаканзеб илавовтсвуч ет ыботч ,йелетитесоп итохирп еыбюл тюянлопыв ыдиордна еыннавориуртснокс оньлаицепс »адапаЗ огокиД риМ« йинечелвзар екрап моксечитсирутуф В
