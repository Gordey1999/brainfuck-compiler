# title: Транслит

# Многомерные массивы конечно тоже можно делать.
# Вот тебе прога, которая делает транслит введенного текста

# При инициализации можно не указывать размерность. Компилятор сам все посчитает
# В данном случае у нас массив строк, то есть массив массивов символов с размерами [32][4]
char map[][] = [
  'a', 'b', 'v', 'g', 'd', 'e', 'zh', 'z', 'i', 'y',
  'k', 'l', 'm', 'n', 'o', 'p', 'r', 's', 't', 'u',
  'f', 'h', 'c', 'ch', 'sh', 'shch', '', 'y', '', 'e',
  'yu', 'ya'
];

char letter;

do
{
    in letter;

    if (letter >= 'а' && letter <= 'я')
    {
        out map[letter - 'а'];
    }
    else if (letter >= 'А' && letter <= 'Я')
    {
        # Еще один оператор: sizeof
        # Возвращает размерность массива
        # Самый быстрый оператор в моем языке
        # Так как значение заранее известно и вычисляется на этапе компиляции
        # В данном случае = 4;
        # На индекс не смотрит. Можно указать sizeof map['dummy'] или sizeof map[]
        for (byte i = 0; i < sizeof map[0]; i++)
        {
            if (map[letter - 'А'][i])
            {
                # Тут переменная нужна чтобы "перевести" byte в char
                # Потому что арифметические операторы всегда возвращают byte
                # А операторов приведения у меня пока нет
                char ch = map[letter - 'А'][i] - ('a' - 'A');
                out ch;
            }
        }
    }
    else
    {
        out letter;
    }
}
while (letter != eol);
